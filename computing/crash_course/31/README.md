# Cybersecurity
[Video Link](https://youtu.be/bPVaOlJ6ln0)

Just like how physical security like locks, fences, and police officers exist to minimize crime in the physical world, [cybersecurity](../glossary/README.md#computer-security) exists to minize crime and harm in the digital world. Computers do not have ethics, they merely follow instructions. Code to take down a [computer network](../glossary/README.md#computer-network) executes in the same way as code to keep a patient's heart pumping. Computing can be used for good or ill-intents. Cybersecurity as a practice attempts to bring justice to this digital domain.

The scope of cybersecurity evolves as fast as the capabilities of computing. It is comprised of a set of techniques to protect the secrecy, integrity, and availability of computer systems and data against threats. _Secrecy_, or _confidentiality_, means that only authorized individuals should be able to access or read specific computer systems and data. Data breaches, where [hackers](../glossary/README.md#security-hacker) reveal credit card information, is an attack on secrecy. _Integrity_ means that only authorized individuals should have the ability to use or modify systems and data. Hackers who discover passwords and send emails masquerading as someone else is an integrity attack. _Availability_ means that authorized individuals should always have access to their systems and data. In a [denial-of-service attack](../glossary/README.md#denial-of-service-attack] hackers overload a website with fake requests to make it slow, or unreachable, for others, attacking the availability of the service.

To achieve the goals of cybersecurity, security experts start with a specification of who the enemy is - called a [theat model](../glossary/README.md#threat-model) at an abstract level. This model profiles attackers: their capabilities, goals, and probable means of attack (known as an _attack vector_). Threat models enable preparations against specific threats, rather than being overwhelmed by all the ways hackers could get to systems and data. How a system is secured depends heavily on who it is being secured against. Often threat models are specified in terms of technical capabilities, for example: "Someone who has physical access to the laptop along with unlimited time".

With a given threat model, _security architects_ need to come up with a solution that keeps a system secure (as long as certain assumptions are met). There are many methods for protecting computer systems, networks, and data. A lot of security boils down to two main security questions:
1. Who are you?
2. What should you have access to?

Access should be given to the right people, but refused to the wrong people. For example: bank employees should be able to open ATMs to restock them, but not the general public. To differentiate between the right and wrong people for whom to grant access [authentication](../glossary/README.md#authentication) is used: the process by which a computer understands who it is interacting with. There are generally three types of authentication, all with their own pros and cons:
1. What you know
2. What you have
3. What you are

_What you know_ authentication is based on knowledge of a secret that should only be known by authorized parties, such as a username and password (known by a computer system and an end user). This is the most widely-used method of autentication in use today because it is the easiest to implement. It can be compromised if hackers guess or otherwise come to know the secret.

For simple passwords or short pin numbers, a computer can perform a [brute-force attack](../glossary/README.md#brute-force-attack) trying every possible combination of letters and numbers, in an incredibly short amount of time. Some computer systems defend against simpler brute force attacks by locking a user out, or adding a delay, after successive failed authentication attempts. More sophisticated attacks, such as those leveraging a [botnet](../glossary/README.md#botnet) can still circumvent these simple defenses.

Increasing the length of PINs and passwords can help, but even 8-digit PINs are easily cracked. Nowdays many websites require a password consists of a mix of upper and lower-case letters, as well as special characters. Doing this exponentially increases the number of possible password combinations. An 8-digit numerical PIN has a hundred million possible combinations - computers can make short work of this number of combinations. An 8-character password containing letters and special characters, by contrast, has more than 600 trillion possible combinations. These passwords may be difficult for users to remember as well - a better approach is to allow for more memorable passwords such as three words joined together. English has around 100,000 words in use, so putting three words together would yield roughly 1 quadrillion possible passwords. In addition, using non-dictionary words is even more effective against more sophisticated kinds of attacks.

_What you have_ authentication, on the other hand, is based on posession of a secret token that only the real user has. An example of this would be a physical key and lock: a user can only unlock a lock if they have the corresponding key. This approach escapes the problem of a key being guessable and typically requires physical presence, which is a big challenge for remote attackers to gain access. This type of authentication can be compromised if an attacker is physically close (keys can be copied, smartphones stolen, and locks picked).

_What you are_ authentication is based on identity. [Biometric](../glossary/README.md#biometrics) authenticators, like fingerprint readers and iris scanners, are examples of this type of authentication. These defenses can be highly secure, but the best technologies in this category are still quite expensive. Also, data from sensors varies over time. _What you know_ and _What you have_ authentication have the nice property of being [deterministic](../glossary/README.md#determinism) - given the same inputs they always respond with the same result. _Biometric authentication_, on the other hand, is probabilistic. There's a chance the system won't recognize a legitimate user, or that the system will misidentify an illegitimate user as a legitimate one. In production systems these chances are low, but not zero. Another issue with biometric authentication is that it can't be reset: if an attacker compromises a user's fingerprint data, for example, there is little recourse to invalidate it.

All forms of authentication have strengths and weaknesses, and all can be compromised in one way or another. Security experts recommend using two or more forms of authentication for important accounts. This is known as _two-factor_ or [multi-factor authenication](../glossary/README.md#multi-factor-authentication). An attacker may be able to guess a user's password or steam their phone, but it's much more difficult to do both.

After authentication is a process known as [access control](../glossary/README.md#access-control). Once a system has identified a user it needs to know what the user should be able to access. For that there is a specification of which users should be able to see, modify, and use what systems/data. This is done through _Permissions_ or _Access Control Lists_ (_ACL_), which describe what access each user has for every file, folder, and program on a computer:
* **READ** permission allows a user to see the contents of a file.
* **WRITE** permission allows a user to modify the contents of a file.
* **EXECUTE** permission allows a user to run a file, such as a program.

For organizations with users at different levels of access privilege it is important access control lists to be configured correctly to ensure secrecy, integrity, and availability. Given varying levels of access, the first general rule of thumb is that users shouldn't be able to "read up". If a user is cleared to read files at one level of access, they shouldn't be able to read files at levels of access above, but should be able to read files at levels of access below their granted level of access. The second general rule of thumb is that users shouldn't be able to "write down". A user should be able to write files at levels of access at, but not below, their granted level of access. This guarantees there is no accidental leakage of higher privileged information to lower levels of access.

This "no read up, no write down" approach is called the [Bell-LaPadula model](https://en.wikipedia.org/wiki/Bell%E2%80%93LaPadula_model). It was formulated for the U.S. Department of Defense's Multi-Level Security policy. There are many other models for access control, wuch as the [Chinese Wall model](https://en.wikipedia.org/wiki/Chinese_wall) and the [Biba model](https://en.wikipedia.org/wiki/Biba_Model). Which model will work best depends on the given use case.

Autentication an daccess control help a computer to determine who a user is and what they should access, but depend on being able to trust the hardware and software that run the autentication and access control programs. If an attacker installs malicious software (called [malware](../glossary/README.md#malware)) compromising the host computer's [operating system](../glossary/README.md#operating-system), there is no way to be certain that security programs do not have a backdoor to allow attackers in. There is still no way to guarantee the security of a program or computing system because even while security software may be "secure" in theory, implementation bugs can still result in vulnerabilities. There do exist techniques to reduce the likelihood of bugs, like quickly finding and patching bugs when they do occur, and mitigating damage when a program is compromised. Most security errors come from implementation error. _In order to reduce implementation error, one must reduce implementation._

One of the holy grails of system level security is a _security kernel_ or a [trusted computing base](../glossary/README.md#trusted-computing-base): a minimal set of operating system software that's close to provably secure. A challenge in constructing these security kernels is deciding what should go into it. Even after minimizing code bloat, it would be great to "guarantee" that code as written is secure. Formally verifying the security of code is an active area of research. The best that exists today is a process called [Independent Verification and Validation](https://en.wikipedia.org/wiki/Verification_and_validation). This process works by having code audited by a crowd of security-minded developers. This is the reason why security code is almost always [open-sourced](../glossary/README.md#open-source-software): it is often difficult for those who wrote the original code to find bugs, but external developers with fresh eyes and different expertise can spot problems.

There are also conferences where like-minded hackers and security experts can mingle and share ideas, the biggest of which is [DEF CON](https://en.wikipedia.org/wiki/DEF_CON), held anually in Las Vegas.

Even after reducing code and auditing it, clever attackers are bound to find tricks that allow them access. With this in mind, good developers should take the approach that when, not if, their programs are compromised the damage should be limited and contained, and not let it compromise other processes running on the machine. This is a principle called _isolation_. To achieve isolation applications can be "sandboxed" wherein the operating system allocates a block of memory that each application can access, but no other program can. It is also possible for a single computer to run multiple Virtual Machines to sandbox individual applications: in the worst case scenario a program will only compromise the virtual machine on which it is running.
 
| [Previous: The World Wide Web](../30/README.md) | [Table of Contents](../README.md#table-of-contents) | Next |
