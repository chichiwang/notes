# Software Engineering
[Video Link](https://youtu.be/O753uuutqH8)

Software applications and programs are comprised of immense amounts of code, more than any single engineer can reasonably accomplish on their own. In order to achieve the goal of building massive software applications programmers rely on a set of tools and practices that taken together form the discipline of [software engineering](../glossary/README.md#software-engineering). This term, _software engineering_, was coined by [Margaret Hamilton](https://en.wikipedia.org/wiki/Margaret_Hamilton_(software_engineer)) who helped NASA to prevent serious problems on their Apollo 11 mission to the moon.

Code can be packaged into functions responsible for a smaller task, however in a truly large codebase even this abstraction is not easy to manage. One approach is to package functions into [hierarchies](../glossary/README.md#class-hierarchy) pulling related code together into _objects_. Related functions can be wrapped up together into a unified object of related functionalities. In general objects can contain other objects, functions, and variables. In order to access functionality in this hierarchy, a programmer will traverse the outer-most objects and work their way down the more deeply nested ones.

The idea of packing up functional units into nested objects is known as [object-oriented progamming](../glossary/README.md#object-oriented-programming). OOP hides complexity by wrapping lower-level details up into higher-leverl components.

Breaking up a complex application into functional units is a great approach to software development for teams. Each team can focus on encapsulating specific behaviorsinto units of functionalities, with each programmer on te team responsible only for a handful of functions. This allows team members to work on different parts of an application simultaneously. Because each team is responsible for a different part of the program, and teams will rely on code written and maintained by other teams, good [documentation](../glossary/README.md#software-documentation) about what each function of the code does and a well-defined [application programming interface](../glossary/README.md#api) (API) is important. An API is the way collaborating programmers interact across various parts of the code - it allows the right people access to the right functions and data.

Object oriented programming languages allow the programmer to specify whether a function or value is _public_ or _private_. A function marked as _private_ can only be accesed by functions within the same object. _Publict_ functions, by contrast, can be called by methods on other objects. This ability to hide complexity, and selectively reveal it, is the essence of Object Oriented Programming, and it's a powerful and popular way to tackle building large and complex programs.

It is important to remember that code, before being compiled, is just text. Code could be written in any text editor - and some programmers do write code this way. Generally, today, however, software developers use special-purpose applications for writing programs: ones that integrate many useful tools for writing, organizing, compiling, and testing code. These tools are called [integrated development environments](../glossary/README.md#integrated-development-environment), or IDEs. All IDEs provide a text editor for writing code, often with useful features like automatic color coding to improve readability. Many IDEs check for syntax errors as you type, like a spell check for code. Big programs contain many source files so IDEs allow programmers to efficiently organize and navigate the entire codebase. Built right into the IDE is the ability to compile and run code, as well as [debugging](../glossary/README.md#debugging) features such as navigating a programmer to a line of code where a crash occurred. Debugging is important because most programmers spend 70 to 80% of their time testing and debugging, not writing new code.

Good tools contained in IDEs can go a long way to helping programmers prevent and find errors. Debugging goes hand in hand with writing code, and it's most often done by an individual or small team.

In addition to coding and debugging, another important part of a programmer's job is documenting their code. This can be done in standalone files called [READMEs](../glossary/README.md#readme) which tells other programmers to read that help file before diving in. Documentation can also happen right in the code itself with [comments](../glossary/README.md#comment): specially marked statements that the program knows to ignore when the code is compiled. They exist only as annotations in the source code to assist other programmers. Good documentation helps programmers when they revisit code they haven't seen for awhile, but it's also crucial for programmers who are totally new to it.

Documentation also promotes [code reuse](../glossary/README.md#code-reuse). Instead of having programmers constantly write the same logic over and over, existing code that accomplishes the task can be used. Programmers can follow the documentation to put the code to work in their program without ever having to read through the actual code.

In addition to IDEs, another important piece of software that helps big teams work collaboratively on big coding projects is called [source control](../glossary/README.md#version-control), also known as _version control_ or _revision control_. Most often at software companies code for projects are stored on centralized servers called a [code repository](../glossary/README.md#source-code-repository). When a programmer wants to work on a piece of code they can _check_ it out, edit the code, and _check_ the code back into the repository (known as _committing_ code) for everyone else to use. Hundreds of programmers can be simultaneously checking in and out pieces of code iteratively building up huge systems.

The big picture version of debugging is [Quality Assurance](../glossary/README.md#quality-assurance) testing, or _QA_. This is where a team rigorously tests out a piece of software, attempting to create unforseen conditions that may lead to defects. Getting all of the wrinkles out is a large effort, but vital in making sure that software works as intended for as many users in as many situations as imaginable before it ships.

You may have heard of [beta software](https://en.wikipedia.org/wiki/Software_release_life_cycle#Beta) - this is a version of software that's mostly complete but not 100% fully tested. Companies will sometimes release beta versions to the public to help identify issues. The stage before beta is known as the [alpha](https://en.wikipedia.org/wiki/Software_release_life_cycle#Alpha) version - a version of the software that is rough and buggy, usually only tested internally.

| [Previous: Alan Turing](../15/README.md) | [Table of Contents](../README.md#table-of-contents) | [Next: Integrated Circuits & Moore's Law](../17/README.md) |
