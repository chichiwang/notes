# Why Lisp?
[Chapter Link](http://www.gigamonkeys.com/book/introduction-why-lisp.html)

Common Lisp is likely the most fun to be had with a computer for those whose greatest pleasure comes from getting a lot done with code that simply, and clearly expresses the intention. More can be done, faster, using Common Lisp than pretty much any other language.

Many proponents of languages use subjective measures to advocate for their language of choice over others. Perl advocates revel in the fact, as the Perl motto states, "There's more than one way to do it." Python fans have their own motto: "There's only one way to do it."

There is no immediately obvious payoff for adopting Common Lisp the way there is for C, Java, and C++. The nearest thing Common Lisp has to a motto is the description: "The programmable programming language." This description gets at one of the biggest advantage Common Lisp still has over other languages. The philosophy follows that what is good for the languages's designer is good for the language's users. Any desire for a feature to be added to the language can be added by the user themselves.

A Common Lisp program tends to provide a clear mapping between the programmer's ideas about how the program works, and the code they actually write. The ideas are not obscured by boilerplate code and endlessly repeated idioms. Even stemic changes to a program's behavior can often be achieved with relatively small changes to the actual code. A programmer will develop code more quickly - there is less code to write.

Common Lisp is also a great language for exploratory programming. It provides several features to help develop code incrementally and interactively. For example, the interactive read-eval-print-loop lets a user continually interact with a program as it is being developed. Other features (dynamic typing and the condition system) allow a user to spend less time struggling with the compiler, and to develop error-handling code interactively.

Another consequence of being "a programmable programming lanauge" is that Common Lisp can easily adopt new ideas about how programming languages should work. For instance, the original implementation of the Common Lisp Object System (CLOS) was as a library written in portable Common Lisp. This allowed Lisp programmers to gain experience with the facilities it provided before it was officially incorporated into the language. Whatever the new programming paradigm, it's extremely likely that Common Lisp will be able to absorb it without requiring any changes to the core language, and without extra preprocessors and extra compilers.

## Where It Began
John McCarthy first conceived Lisp in 1956. At the time it was designed for "symbolic data processing" and derived its name from one of the things it was good at: LISt Processing. Common Lisp is the modern descendant of this original language and comes equipped with an array of modern data types; a condition system that provides flexibility missing from the exception systems of languages such as Java, Python, and C++; powerful facilities for object-oriented programming; several language facilities that just don't exist in other programming languages.

McCarthy was (and still is) an artificial intelligence (AI) researcher, and many of the features he built into his initial version of the language made it an excellent choice for AI programming. During the AI boom of the 1980s, AI programmers needed a powerful language and they grew Lisp into the language that they needed. The same forces that drove Lisp's feature evolution also pushed the envelope along other dimensions such as squeezing performance out of scarce computing resources. Modern Common Lisp implementations are heirs to those early efforts and often include sophisticate, native machine code-generating compilers. A good Lisp compiler can generate machine code quite similar to what might be generated by a C compiler.

By the early 1980s there was such a proliferation of Lisp systems and dialects that DARPA began expressing concern about the Lisp community splintering. To address this concern, a grassroots group of Lisp hackers got together in 1981 and began the process of standardizing a new language called Common Lisp that combined the best features from the existing Lisp dialects. By 1986 the first Common Lisp implementations were available. In 1996, the American National Standards Institute (ANSI) released a standard for Common Lisp that built on ane extended the language specified in the earlier 1981 efforts.

These days Common Lisp is evolving much like other open-source languages. So, on one hand, Lisp is one of computer science's "classical" languages, based on ideas that have stood the test of time. On the other, it's a thoroughly modern, general-purpose language whose design reflects a deeply pragmatic approach to solving real problems as efficiently and robustly as possible.

Other than Common Lisp, the one general-purpose Lisp dialect that still has an active user community is Scheme. Common Lisp borrowed a few important features from Scheme but never intended to replace it. Scheme also has the benefit of making it relatively easy to understand the whole language as specified in the standard. It does so at the cost of omitting many useful features that are standardized in Common Lisp. The omission of these standard features makes it harder to write portable Scheme code than to write portable Common Lisp code. Scheme emphasizes a functional programming style and the use of recursion much more than Common Lisp does.

Two other Lisp dialects still in widespread use are Elisp, the extension language for the Emacs editor, and Autolisp, the extension language for Autodesk's AutoCAD computer-aided design tool.

| [Table of Contents](../README.md#table-of-contents) | Next |
