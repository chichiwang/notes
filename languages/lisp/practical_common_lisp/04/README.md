# Syntax and Semantics
[Chapter Link](http://www.gigamonkeys.com/book/syntax-and-semantics.html)

Lisp's syntax is different from the syntax of languages descended from [Algo](https://en.wikipedia.org/wiki/ALGOL). It's two most distinguishing characteristics are the extensive use of parentheses and [prefix notation](https://en.wikipedia.org/wiki/Polish_notation).

It is worth looking at how Lisp's syntax and semantics are defined, and how it differs from many other languages:

## Sections
* [Language Processing](#language-processing)
* [S-expressions](#s-expressions)
  * [Numbers](#numbers)

## Language Processing
In most programming languages the language processor takes a sequence of characters representing the text of a program and either executes the behaviors indicated (interpreter) or produces a copiled version of the program that will execute the behaviors when run (compiler). Language processors are usually divided into subsystems that are each responsible for one part of translating a program text into behavior or object code. Typically a language processor is split into three phases, each of which feeds the into the next:
1. **A lexical analyzer**: breaks up the stream of characters into tokens.
2. **A Parser**: takes lexical tokens and generates an [abstract syntax tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) (a tree representing the expressions in the program).
3. **Evaluator**: takes an _abstract syntax tree_ either interprets it directly or compiles it into another language (like machine code).

Rather than a single abstraction that takes text to program behavior in a single step (as in the language processor described above) Common Lisp abstracts two processes:
1. **Reader**: translates text into Lisp objects called _s-expressions_. S-expression syntax includes syntax for lists of arbitrary objects, including other lists, therefore s-expressions can represent arbitrary tree expressions (much like an abstract syntax tree).
2. **Evaluator**: implements the semantics of the language in terms of Lisp objects. It defines a syntax of Lisp _forms_ that can be built out of s-expressions.

Not all s-expressions are legal Lisp forms. For example `(foo 1 2)` and `("foo" 1 2)` are both s-expressions, but only the former can be a Lisp form since a list that starts with a string has no meaning as a Lisp form.

Some consequences of this split in processing:
* S-expressions can be used as an externizable data format (as seen in the [previous chapter](../03/README.md#saving-and-loading-the-database)) for data other than source code. `READ` is used to read s-expressions, and `PRINT` is used to print to it.
* Since the semantics of the language are defined in terms of trees of objects rather than strings of characters, it is easier to generate code within the language than it would be if the code has to be generated as text. (Generating code completely from scratch is only marginally easier - building up lists vs. building up strings is about the same amount of work.
* Code can be generated by manipulating existing data. This is the basis for Lisp's macros.

[▲ Return to Sections](#sections)

## S-expressions

The basic elements of [s-expressions](https://en.wikipedia.org/wiki/S-expression) are _lists_ and _atoms_.

**Lists** are delimited by parentheses and can contain any number of white-space separated elements. **Atoms** are everything else. The elements of lists are themselves s-expressions (atoms or nested lists). Comments are not technically s-expresions. They start with a semicolon and extend to the end of a line. They are treated essentially like whitespace.

The syntactic rules governing the most common kinds of atoms:

### Numbers
Any sequence of digits, possibly prefaced by a sign (`+` and `-`), contianing a decimal point (`.`) or a solidus (`/`), or ending with an exponent marker is read as a number:
```lisp
123       ; the integer one hundred twenty-three
3/7       ; the ratio three-sevenths
1.0       ; the floating-point number one in default precision
1.0e0     ; another way to write the same floating-point number
1.0d0     ; the floating-point number one in "double" precision
1.0e-4    ; the floating-point equivalent to one-ten-thousandth
+42       ; the integer forty-two
-42       ; the integer negative forty-two
-1/4      ; the ratio negative one-quarter
-2/8      ; another way to write negative one-quarter
246/2     ; another way to write the integer one hundred twenty-three
```

These different forms represent different kinds of numbers: integers, ratios, and floating point. Lisp also supports complex numbers.

Numbers may be notated many ways. No matter how they are written, all rationals (integers and ratios) are represented internally in "simplified" form. The objects that represent `-2/8` and `-1/4` are not distinct from one another. `1.0` and `1.0e0` are just different ways of writing the same number. On the other hand `1.0`, `1.0d0`, and `1` can all denote different objects because the different floating-point representations and integers are different types.

[▲ Return to Sections](#sections)

| [Previous: A Simple Database](../03/README.md) | [Table of Contents](../README.md#notes) | Next |
