# Syntax and Semantics
[Chapter Link](http://www.gigamonkeys.com/book/syntax-and-semantics.html)

Lisp's syntax is different from the syntax of languages descended from [Algo](https://en.wikipedia.org/wiki/ALGOL). It's two most distinguishing characteristics are the extensive use of parentheses and [prefix notation](https://en.wikipedia.org/wiki/Polish_notation).

It is worth looking at how Lisp's syntax and semantics are defined, and how it differs from many other languages:

## Sections
* [Language Processing](#language-processing)

## Language Processing
In most programming languages the language processor takes a sequence of characters representing the text of a program and either executes the behaviors indicated (interpreter) or produces a copiled version of the program that will execute the behaviors when run (compiler). Language processors are usually divided into subsystems that are each responsible for one part of translating a program text into behavior or object code. Typically a language processor is split into three phases, each of which feeds the into the next:
1. **A lexical analyzer**: breaks up the stream of characters into tokens.
2. **A Parser**: takes lexical tokens and generates an [abstract syntax tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) (a tree representing the expressions in the program).
3. **Evaluator**: takes an _abstract syntax tree_ either interprets it directly or compiles it into another language (like machine code).

Rather than a single abstraction that takes text to program behavior in a single step (as in the language processor described above) Common Lisp abstracts two processes:
1. **Reader**: translates text into Lisp objects called _s-expressions_. S-expression syntax includes syntax for lists of arbitrary objects, including other lists, therefore s-expressions can represent arbitrary tree expressions (much like an abstract syntax tree).
2. **Evaluator**: implements the semantics of the language in terms of Lisp objects. It defines a syntax of Lisp _forms_ that can be built out of s-expressions.

Not all s-expressions are legal Lisp forms. For example `(foo 1 2)` and `("foo" 1 2)` are both s-expressions, but only the former can be a Lisp form since a list that starts with a string has no meaning as a Lisp form.

Some consequences of this split in processing:
* S-expressions can be used as an externizable data format (as seen in the [previous chapter](../03/README.md#saving-and-loading-the-database)) for data other than source code. `READ` is used to read s-expressions, and `PRINT` is used to print to it.
* Since the semantics of the language are defined in terms of trees of objects rather than strings of characters, it is easier to generate code within the language than it would be if the code has to be generated as text. (Generating code completely from scratch is only marginally easier - building up lists vs. building up strings is about the same amount of work.
* Code can be generated by manipulating existing data. This is the basis for Lisp's macros.

[â–² Return to Sections](#sections)

| [Previous: A Simple Database](../03/README.md) | [Table of Contents](../README.md#notes) | Next |
