# Syntax and Semantics
[Chapter Link](http://www.gigamonkeys.com/book/syntax-and-semantics.html)

Lisp's syntax is different from the syntax of languages descended from [Algo](https://en.wikipedia.org/wiki/ALGOL). It's two most distinguishing characteristics are the extensive use of parentheses and [prefix notation](https://en.wikipedia.org/wiki/Polish_notation).

It is worth looking at how Lisp's syntax and semantics are defined, and how it differs from many other languages:

## Sections
* [Language Processing](#language-processing)
* [S-expressions](#s-expressions)
  * [Numbers](#numbers)
  * [Strings](#strings)
  * [Names](#names)
* [S-expressions as Lisp Forms](#s-expressions-as-lisp-forms)

[◂ Return to Table of Contents](../README.md)

## Language Processing
In most programming languages the language processor takes a sequence of characters representing the text of a program and either executes the behaviors indicated (interpreter) or produces a copiled version of the program that will execute the behaviors when run (compiler). Language processors are usually divided into subsystems that are each responsible for one part of translating a program text into behavior or object code. Typically a language processor is split into three phases, each of which feeds the into the next:
1. **A lexical analyzer**: breaks up the stream of characters into tokens.
2. **A Parser**: takes lexical tokens and generates an [abstract syntax tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) (a tree representing the expressions in the program).
3. **Evaluator**: takes an _abstract syntax tree_ either interprets it directly or compiles it into another language (like machine code).

Rather than a single abstraction that takes text to program behavior in a single step (as in the language processor described above) Common Lisp abstracts two processes:
1. **Reader**: translates text into Lisp objects called _s-expressions_. S-expression syntax includes syntax for lists of arbitrary objects, including other lists, therefore s-expressions can represent arbitrary tree expressions (much like an abstract syntax tree).
2. **Evaluator**: implements the semantics of the language in terms of Lisp objects. It defines a syntax of Lisp _forms_ that can be built out of s-expressions.

Not all s-expressions are legal Lisp forms. For example `(foo 1 2)` and `("foo" 1 2)` are both s-expressions, but only the former can be a Lisp form since a list that starts with a string has no meaning as a Lisp form.

Some consequences of this split in processing:
* S-expressions can be used as an externizable data format (as seen in the [previous chapter](../03/README.md#saving-and-loading-the-database)) for data other than source code. `READ` is used to read s-expressions, and `PRINT` is used to print to it.
* Since the semantics of the language are defined in terms of trees of objects rather than strings of characters, it is easier to generate code within the language than it would be if the code has to be generated as text. (Generating code completely from scratch is only marginally easier - building up lists vs. building up strings is about the same amount of work.
* Code can be generated by manipulating existing data. This is the basis for Lisp's macros.

[▲ Return to Sections](#sections)

## S-expressions
The basic elements of [s-expressions](https://en.wikipedia.org/wiki/S-expression) are _lists_ and _atoms_.

**Lists** are delimited by parentheses and can contain any number of white-space separated elements. **Atoms** are everything else. The elements of lists are themselves s-expressions (atoms or nested lists). Comments are not technically s-expresions. They start with a semicolon and extend to the end of a line. They are treated essentially like whitespace.

Numbers, strings, and symbols can be combined with parentheses-delimited lists to build s-expressions representing arbitrary trees of objects, such as:
```lisp
x             ; the symbol X
()            ; the empty list
(1 2 3)       ; a list of three numbers
("foo" "bar") ; a list of two strings
(x y z)       ; a list of three symbols
(x 1 "foo")   ; a list of a symbol, a number, and a string
(+ (* 2 3) 4) ; a list of a symbol, a list, and a number.
```

The following is a slightly more complex example that has a four-item list that contains two symbols, an empty list, and another list that itself contains two symbols and a string:
```lisp
(defun hello-world ()
  (format t "hello, world"))
```

### Numbers
Any sequence of digits, possibly prefaced by a sign (`+` and `-`), contianing a decimal point (`.`) or a solidus (`/`), or ending with an exponent marker is read as a number:
```lisp
123       ; the integer one hundred twenty-three
3/7       ; the ratio three-sevenths
1.0       ; the floating-point number one in default precision
1.0e0     ; another way to write the same floating-point number
1.0d0     ; the floating-point number one in "double" precision
1.0e-4    ; the floating-point equivalent to one-ten-thousandth
+42       ; the integer forty-two
-42       ; the integer negative forty-two
-1/4      ; the ratio negative one-quarter
-2/8      ; another way to write negative one-quarter
246/2     ; another way to write the integer one hundred twenty-three
```

These different forms represent different kinds of numbers: integers, ratios, and floating point. Lisp also supports complex numbers.

Numbers may be notated many ways. No matter how they are written, all rationals (integers and ratios) are represented internally in "simplified" form. The objects that represent `-2/8` and `-1/4` are not distinct from one another. `1.0` and `1.0e0` are just different ways of writing the same number. On the other hand `1.0`, `1.0d0`, and `1` can all denote different objects because the different floating-point representations and integers are different types.

### Strings
String literals are enclosed in double quotes. Within a string, a backslash (`\`) escapes the next character. The only characters that must be escaped within a string are double quotes and backslashes:
```lisp
"foo"     ; the string containing the characters f, o, and o.
"fo\o"    ; the same string
"fo\\o"   ; the string containing the characters f, o, \, and o.
"fo\"o"   ; the string containing the characters f, o, ", and o.
```

### Names
Names used in Lisp, such as `FORMAT`, `hello-world`, and `*db*` are represented by objects called _sympbols_. The _reader_ does not know how a name will be used (whether it's the name of a variable, function, or something else). The reader simply reads a sequence of characters and builds an object to represent the name.

Almost any character can appear in a name, with a few exceptions:
* Whitespaces cannot appear in names (lists are separated by whitespace).
* Digits are valid, so long as the name as a whole cannot be interpreted as a number.
* Names can contain periods, but the reader can't read a name that consists of only periods.
* 10 characters that serve syntactic purposes cannot appear in names:
  * Open and close parentheses: `(`, `)`
  * Double and single quotes: `"`, `'`
  * Backticks: `` ` ``
  * Commas: `,`
  * Colons and semicolons: `:`, `;`
  * Backslash: `\`
  * Vertical bar: `|`

While reading names, the reader converts all unescaped chaacers in a name to their uppercase equivalents. The reader reads `foo`, `Foo`, and `FOO` as the same symbol: _FOO_. However, `\f\o\o\` and `|foo|` will both be read as _foo_, which is a different object than the symbol _FOO_. Standard style is to write code in all lowercase and let the reader change names to uppercase.

To ensure the same textual name is always read as the same symbol, the reader _interns_ symbols. After the reader has read a name and converted it to all uppercase, it looks in a table (called a _package_) for an existing symbol with the same name. If a symbol with the same name exists in the package, it returns the symbol already in the table. Otherwise it creates a new symbol and adds it to the table. In this way, wherever the same name appears in any s-expression, the same object will be used to represent it.

Certain naming conventions exist distinct to Lisp:
* Names are lowercase (as in `foo`)
* Names are hyphenated (as in `hello-world`)
* Global variables are given names that start and end with `*` (as in `*db*`)
* Constants are given names that start and end with `+` (as in `+my-const+`)
* Somtimes, particularly low-level functions are given names that start with `%` or `%%`

[▲ Return to Sections](#sections)

## S-expressions as Lisp Forms

After the reader has translated the text sourcecode into s-expressions, the s-expressions can be evaluated as Lisp code (not every s-expression that the reader can read can be evaluated as Lisp code).

Common Lisp's evaluation rule defines a second level of syntax that determines which s-expressions can be treated as Lisp forms:
* Any _atom_ (non-list or the empty list) is a legal Lisp form.
* Any list that has a symbol as its first element is a legal Lisp form.
  * Three different list forms are evaluated in three different ways, the evaluator must determine whether the symbol that starts the list is the name of a _function_, _macro_, or _special operator_.
  * If the symbol has not yet been defined, it is assumed to be a _function_ name.

_Atoms_, the simplest Lisp forms, can be divided into 2 categories:
* Symbols: evaluated as a form, is considered the name of a variable and evaluates to the current value of the variable.
  * Some symbols are also self-evaluating: the variables they name can be assigned the value of the symbol itself.
    * `T` and `NIL` are self-evaluating symbols.
    * Keyword symbols (symbols whose names start with `:` are self-evaluating symbols.
* Everything else: numbers, strings, etc. are _self-eveluating objects_. When these expressions are passed to the notional evaluation function, it is simply returned.

The _evaluator_ can be thought of as a function that takes an argument of syntactically correct Lisp and returns a value: this is the _value_ of the form. When the evaluator is a _compiler_, it converts the expression into code that will compute the appropriate value when its run.

| [Previous: A Simple Database](../03/README.md) | [Table of Contents](../README.md#notes) | Next |
