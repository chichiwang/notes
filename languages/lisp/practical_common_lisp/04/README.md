# Syntax and Semantics
[Chapter Link](http://www.gigamonkeys.com/book/syntax-and-semantics.html)

Lisp's syntax is different from the syntax of languages descended from [Algo](https://en.wikipedia.org/wiki/ALGOL). It's two most distinguishing characteristics are the extensive use of parentheses and [prefix notation](https://en.wikipedia.org/wiki/Polish_notation).

It is worth looking at how Lisp's syntax and semantics are defined, and how it differs from many other languages:

## Sections
* [Language Processing](#language-processing)
* [S-expressions](#s-expressions)
  * [Numbers](#numbers)
  * [Strings](#strings)
  * [Names](#names)
* [S-expressions as Lisp Forms](#s-expressions-as-lisp-forms)
  * [Function Calls](#function-calls)
  * [Special Operators](#special-operators)
  * [Macros](#macros)

[◂ Return to Table of Contents](../README.md)

## Language Processing
In most programming languages the language processor takes a sequence of characters representing the text of a program and either executes the behaviors indicated (interpreter) or produces a copiled version of the program that will execute the behaviors when run (compiler). Language processors are usually divided into subsystems that are each responsible for one part of translating a program text into behavior or object code. Typically a language processor is split into three phases, each of which feeds the into the next:
1. **A lexical analyzer**: breaks up the stream of characters into tokens.
2. **A Parser**: takes lexical tokens and generates an [abstract syntax tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) (a tree representing the expressions in the program).
3. **Evaluator**: takes an _abstract syntax tree_ either interprets it directly or compiles it into another language (like machine code).

Rather than a single abstraction that takes text to program behavior in a single step (as in the language processor described above) Common Lisp abstracts two processes:
1. **Reader**: translates text into Lisp objects called _s-expressions_. S-expression syntax includes syntax for lists of arbitrary objects, including other lists, therefore s-expressions can represent arbitrary tree expressions (much like an abstract syntax tree).
2. **Evaluator**: implements the semantics of the language in terms of Lisp objects. It defines a syntax of Lisp _forms_ that can be built out of s-expressions.

Not all s-expressions are legal Lisp forms. For example `(foo 1 2)` and `("foo" 1 2)` are both s-expressions, but only the former can be a Lisp form since a list that starts with a string has no meaning as a Lisp form.

Some consequences of this split in processing:
* S-expressions can be used as an externizable data format (as seen in the [previous chapter](../03/README.md#saving-and-loading-the-database)) for data other than source code. `READ` is used to read s-expressions, and `PRINT` is used to print to it.
* Since the semantics of the language are defined in terms of trees of objects rather than strings of characters, it is easier to generate code within the language than it would be if the code has to be generated as text. (Generating code completely from scratch is only marginally easier - building up lists vs. building up strings is about the same amount of work.
* Code can be generated by manipulating existing data. This is the basis for Lisp's macros.

[▲ Return to Sections](#sections)

## S-expressions
The basic elements of [s-expressions](https://en.wikipedia.org/wiki/S-expression) are _lists_ and _atoms_.

**Lists** are delimited by parentheses and can contain any number of white-space separated elements. **Atoms** are everything else. The elements of lists are themselves s-expressions (atoms or nested lists). Comments are not technically s-expresions. They start with a semicolon and extend to the end of a line. They are treated essentially like whitespace.

Numbers, strings, and symbols can be combined with parentheses-delimited lists to build s-expressions representing arbitrary trees of objects, such as:
```lisp
x             ; the symbol X
()            ; the empty list
(1 2 3)       ; a list of three numbers
("foo" "bar") ; a list of two strings
(x y z)       ; a list of three symbols
(x 1 "foo")   ; a list of a symbol, a number, and a string
(+ (* 2 3) 4) ; a list of a symbol, a list, and a number.
```

The following is a slightly more complex example that has a four-item list that contains two symbols, an empty list, and another list that itself contains two symbols and a string:
```lisp
(defun hello-world ()
  (format t "hello, world"))
```

### Numbers
Any sequence of digits, possibly prefaced by a sign (`+` and `-`), contianing a decimal point (`.`) or a solidus (`/`), or ending with an exponent marker is read as a number:
```lisp
123       ; the integer one hundred twenty-three
3/7       ; the ratio three-sevenths
1.0       ; the floating-point number one in default precision
1.0e0     ; another way to write the same floating-point number
1.0d0     ; the floating-point number one in "double" precision
1.0e-4    ; the floating-point equivalent to one-ten-thousandth
+42       ; the integer forty-two
-42       ; the integer negative forty-two
-1/4      ; the ratio negative one-quarter
-2/8      ; another way to write negative one-quarter
246/2     ; another way to write the integer one hundred twenty-three
```

These different forms represent different kinds of numbers: integers, ratios, and floating point. Lisp also supports complex numbers.

Numbers may be notated many ways. No matter how they are written, all rationals (integers and ratios) are represented internally in "simplified" form. The objects that represent `-2/8` and `-1/4` are not distinct from one another. `1.0` and `1.0e0` are just different ways of writing the same number. On the other hand `1.0`, `1.0d0`, and `1` can all denote different objects because the different floating-point representations and integers are different types.

### Strings
String literals are enclosed in double quotes. Within a string, a backslash (`\`) escapes the next character. The only characters that must be escaped within a string are double quotes and backslashes:
```lisp
"foo"     ; the string containing the characters f, o, and o.
"fo\o"    ; the same string
"fo\\o"   ; the string containing the characters f, o, \, and o.
"fo\"o"   ; the string containing the characters f, o, ", and o.
```

### Names
Names used in Lisp, such as `FORMAT`, `hello-world`, and `*db*` are represented by objects called _sympbols_. The _reader_ does not know how a name will be used (whether it's the name of a variable, function, or something else). The reader simply reads a sequence of characters and builds an object to represent the name.

Almost any character can appear in a name, with a few exceptions:
* Whitespaces cannot appear in names (lists are separated by whitespace).
* Digits are valid, so long as the name as a whole cannot be interpreted as a number.
* Names can contain periods, but the reader can't read a name that consists of only periods.
* 10 characters that serve syntactic purposes cannot appear in names:
  * Open and close parentheses: `(`, `)`
  * Double and single quotes: `"`, `'`
  * Backticks: `` ` ``
  * Commas: `,`
  * Colons and semicolons: `:`, `;`
  * Backslash: `\`
  * Vertical bar: `|`

While reading names, the reader converts all unescaped chaacers in a name to their uppercase equivalents. The reader reads `foo`, `Foo`, and `FOO` as the same symbol: _FOO_. However, `\f\o\o\` and `|foo|` will both be read as _foo_, which is a different object than the symbol _FOO_. Standard style is to write code in all lowercase and let the reader change names to uppercase.

To ensure the same textual name is always read as the same symbol, the reader _interns_ symbols. After the reader has read a name and converted it to all uppercase, it looks in a table (called a _package_) for an existing symbol with the same name. If a symbol with the same name exists in the package, it returns the symbol already in the table. Otherwise it creates a new symbol and adds it to the table. In this way, wherever the same name appears in any s-expression, the same object will be used to represent it.

Certain naming conventions exist distinct to Lisp:
* Names are lowercase (as in `foo`)
* Names are hyphenated (as in `hello-world`)
* Global variables are given names that start and end with `*` (as in `*db*`)
* Constants are given names that start and end with `+` (as in `+my-const+`)
* Somtimes, particularly low-level functions are given names that start with `%` or `%%`

[▲ Return to Sections](#sections)

## S-expressions as Lisp Forms

After the reader has translated the text sourcecode into s-expressions, the s-expressions can be evaluated as Lisp code (not every s-expression that the reader can read can be evaluated as Lisp code).

Common Lisp's evaluation rule defines a second level of syntax that determines which s-expressions can be treated as Lisp forms:
* Any _atom_ (non-list or the empty list) is a legal Lisp form.
* Any list that has a symbol as its first element is a legal Lisp form.
  * Three different list forms are evaluated in three different ways, the evaluator must determine whether the symbol that starts the list is the name of a _function_, _macro_, or _special operator_.
  * If the symbol has not yet been defined, it is assumed to be a _function_ name.

_Atoms_, the simplest Lisp forms, can be divided into 2 categories:
* Symbols: evaluated as a form, is considered the name of a variable and evaluates to the current value of the variable.
  * Some symbols are also self-evaluating: the variables they name can be assigned the value of the symbol itself.
    * `T` and `NIL` are self-evaluating symbols.
    * Keyword symbols (symbols whose names start with `:` are self-evaluating symbols.
* Everything else: numbers, strings, etc. are _self-eveluating objects_. When these expressions are passed to the notional evaluation function, it is simply returned.

The _evaluator_ can be thought of as a function that takes an argument of syntactically correct Lisp and returns a value: this is the _value_ of the form. When the evaluator is a _compiler_, it converts the expression into code that will compute the appropriate value when its run.

### Function Calls
The basic syntax of a function call form:
```
(function-name argument*)
```

Where each of the arguments is a Lisp form. The evaluation of a function call form is to evaluate the remaining elements of the list as Lisp forms and pass the resulting values to the named function.

```lisp
(+ 1 2)
```

The preceding expression is evaluated by first evaluating `1`, then `2`, and then passing the resulting values to the `+` function which returns `3`.

```lisp
(* (+ 1 2) (- 3 4))
```

The precending expression is evaluated by first evaluating the arguments `(+ 1 2)` and `(- 3 4)` before passing them to the `*` function. Eventually the values `3` and `-1` are passed to the `*` function which returns `-3`.

Functions are used for many of the operators and things that require special syntax in other languages. In this way Lisp's syntax remains regular.

### Special Operators
Not all operations can be defined as functions. Because all arguments to a function are evaluated before the function is called, there is no way to write a function that behaves like the `IF` operator:
```lisp
(if x (format t "yes") (format t "no))
```

If `IF` were a function, the evaluator would evaluate the argument expressions from left to right. First `x` would be evaluated as a variable yielding a value, then `(format t "yes")` would be evaluated as a function call yielding `NIL` after printing `"yes"` to standard output. The same would happen next for `(format t "no")`. Only after all three expressions following `IF` were evaluated would they be passed to `IF`, too late for it to control which of the two `FORMAT` expressions get evaluated.

Common Lisp defines a couple dozen special operators (`IF` being one of them) that behave differently than functions. There are 25 in all, but only a small handful are used directly in day-to-day programming. The set of special operators is fixed by the language standard.

When the first element of a list is a symbol naming a special operator, the rest of the expressions in the list are evaluated according to the rule for that operator.

The basic form of an `IF` expression is:
```
(if test-form then-form [else-form])
```

First the evaluator evaluates the `test-form`. If that evaluates to a non-`NIL` value, then evaluate the `then-form` expression and return its value. Otherwise return the value of evaluating the `else-form` if provided, or `NIL` if it is not.

The special operator `QUOTE` has simpler evaluation rules:
```lisp
(quote (+ 1 2))
```

This special operator takes a single expression as its argument and returns it, unevaluated. The preceding expression evaluates to the list `(+ 1 2)` and not the value `3`.

A special syntax for `QUOTE` is built into the reader using the `'` character:
```lisp
'(+ 1 2)
```

From the perspective of the evaluator, both expressions are understood in the same way: a list whose first element is the symbol `QUOTE` and whose second element is the list `(+ 1 2)`.

The special operators implement features of the language that require some special processing by the evaluator.

### Macros
Macros give users of the language a way to extend its syntax. A macro is a function that takes s-expressions as arguments and returns a Lisp form that's then evaluated in place of the macro form. The evaluation of a macro form occurs in two phases:
1. The elements of the macro form are passed, unevaluated, to the macro function.
2. The form returned by the macro function (its _expansion_) is evaluated according to the normal evaluation rules.

It is important to keep a clear mental model of the two phases of evaluating a macro form. When Lisp code is compiled, the two phases happen at completely different times.

When a whole file of source code is compiled with the function `COMPILE-FILE`, all the macro forms in the file are recursively expanded until the code consists of nothing but the function call forms and special forms. This macroless code is compiled into a FASL file that the `LOAD` function knows how to load. This compiled code isn't executed until the file is loaded.

Because macros generate their expansions at compile time, they can do relatively large amounts of work generating their expansion without having to pay for it when the file is loaded or the functions defined in the file are called.

Since the evaluator doesn't evaluate elements of the macro form before passing them to the macro function, they don't need to be well-formed Lisp forms. Each macro defines its own local syntax: it assigns a meaning to the s-expressions in the macro form by virtue of how it uses them to generate its expansion.

Macros serve a different purpse than functions, providing a hook into the compiler.

[▲ Return to Sections](#sections)

| [Previous: A Simple Database](../03/README.md) | [Table of Contents](../README.md#notes) | Next |
