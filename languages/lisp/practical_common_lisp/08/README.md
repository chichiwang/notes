# Macros: Custom Defined
[Chapter Link](http://www.gigamonkeys.com/book/macros-defining-your-own.html)

Perhaps the biggest barrier to proper understanding of macros is that they are so well integrated into the language. The key to understanding macros is to clearly understand the distinction between the code that generates code (macros) and the code that eventually makes up the program (everything else).

## Sections
* [Macro Expansion vs. Runtime](#macro-expansion-vs-runtime)
* [DEFMACRO](#defmacro)
* [A Sample Macro: do-primes](#a-sample-macro-do-primes)
* [Macro Parameters](#macro-parameters)
* [Generating the Expansion](#generating-the-expansion)
* [Plugging the Leaks](#plugging-the-leaks)
* [Macro-Writing Macros](#macro-writing-macros)
  * [ONCE-ONLY](#once-only)

[◂ Return to Table of Contents](../README.md)

## Macro Expansion vs. Runtime
A macro definition is a program that will be used by the compiler to generate the code that will then be compiled. Only after all macros have been fully expanded and the resulting code compiled can a program run. _Macro expansion time_ is the step where macros are executed. This is distinct from _runtime_ when regular code, including the code generated by macros, run.

Code running at macro expansion time runs in a very different environment than code running at runtime. At macro expansion time there is no way to access the data that will exist at runtime: code running at macro expansion time can deal only with the data that's inherent in the source code.

Take the example of the following code:
```lisp
(defun foo (x)
  (when (> x 10) (print 'big)))
```

`WHEN` is a macro. At macro expansion time there is no call to `FOO` and therefore there is no value associated with `x`. The values the compiler passes to `WHEN` are the Lisp lists representing the source code: `(> x 10)` and `(print 'big)`. Supposing that `WHEN` is defined the following way:
```lisp
(defmacro when (condition &rest body)
  `(if ,condition (progn ,@body)))
```

When the code in `FOO` is compiled, the `WHEN` macro will be run with those two forms as arguments. The parameter `condition` will be bound to the form `(> x 10)`, and the form `(print 'big)` will be collected into a list that will become the value of the `&rest body` parameter. The backquote expression will generate this code:
```lisp
(if (> x 10) (progn (print 'big)))
```

When Lisp is interpreted, rather than compiked, this distinction between macro expansion time and runtime is less clear because they are temporally intertwined. The language doesn't specify exactly how an interpreter must handle macros. Regardless, macros are always passed the unevaluated Lisp objects representing the subforms of the macro form. The job of the macro is to produce code that will do something rather than to do anything directly.

[▲ Return to Sections](#sections)

## DEFMACRO
`DEFMACRO` stands for _DEFine MACRO_ and is used to define a macro. The basica skeleton of `DEFMACRO` is:
```lisp
(defmacro name (parameter*)
  "Optional documentation string."
  body-form*)
```

Macros can use the full power of Lisp to generate their expansion. The job of a macro is to translate a macro form (a lisp form whose first element is the name of the macro) into code that does a particular thing. The first step of writing a macro is to write at least one example of a call to the macro and the code into which that code should expand. The second step is to write the actual macro code.

Simple macros will consist of a backquoted template with macro parameters plugged into the right places. Complex macros will be significant programs in their own right, complete with helper functions and data structures.

After writing the macro, it needs to be hardened against leaking details of its implementation. Leaky macro abstractions can potentially interact with code in the calling environment in undesirable ways.

To sum up creating a macro:
1. Write a sample call to the macro and the code it should expand into.
2. Write code that generates the handwritten expansion fronm the arguments in the sample call.
3. Ensure the macro abstraction does not leak.

[▲ Return to Sections](#sections)

## A Sample Macro: do-primes
We will create a sample macro `DO-PRIMES` that provides a looping construct similar to `DOTIMES` and `DOLIST` except that instead of iterating over integers or elements of a list, it iterates over successive prime numbers.

First we define utility functions:
```lisp
(defun primep (number)
  (when (> number 1)
    (loop for fac from 2 to (isqrt number) never (zerop (mod number fac)))))

(defun next-prime (number)
  (loop for n from number when (primep n) return n))
```

`PRIMEP` tests whether a given number is prime. `NEXT-PRIME` returns the next prime number greater than or equal to its argument.

Following the steps from the [previous section](#defmacro), first we need one example call to the macro:
```lisp
(do-primes (p 0 19)
  (format t "~d" p))
```

The above code intends to express a loop that executes the body once each for each prime number greater or equal to `0` and less than or equal to `19`. The variable `p` will be assigned to that number on every iteration of the `DO-PRIMES` loop.

The above code could expand to:
```lisp
(do ((p (next-prime 0) (next-prime (+1 p))))
    ((> p 19))
  (format t "~d" p))
```

[▲ Return to Sections](#sections)

## Macro Parameters
The first step in any macro is to extract the parts of the lisp argument objects that are needed to compute the expansion. For macros that simply interpolate their arguments directly into a template this step is trivial - defining the right parameters to hold the different arguments will suffice.

This is a bit more complex for a macro like `DO-PRIMES`. The first argument to the `DO-PRIMES` call is a list containing the name of the loop variable `p`, the lower bound `0`, and the upper bound `19`. This list as a whole does not appear in the expansion, these three arguments are split up in different locations.

`DO-PRIMES` can be defined with two parameters: one to hold the list and a `&rest` parameter to hold the body forms. The list will need to be taken apart:
```lisp
(defmacro do-primes (var-and-range &rest body)
  (let ((var (first var-and-range))
        (start (second var-and-range))
        (end (third var-and-range)))
    `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
         ((> ,var ,end))
      ,@body)))
```

In the above definition the variables `var`, `start`, and `end` each hold a value extracted from `var-and-range`. These variables are then interpolated into the backquote expression that generates `DO-PRIME`'s expansion.

`var-and-range` does not need to be extracted explicitly in this way, however, because macro parameter lists are what are called _destructuring_ parameter lists. Destructuring involves taking apart a structure (in this case the list structure of the forms passed to a macro).

Within a destructuring parameter list a parameter name can be replaced with a nested parameter list. For example, `var-and-range` in the above definition can be replaced with a list `(var start end)` and the three elements in the list will automatically be destructured into those three parameters.

Another special feature of macro parameter lists is that `&body` can be used as a synonym for `&rest`. Semantically `&body` and `&rest` are equivalent, but many development environments will use the presence of a `&body` parameter to modify how they indent uses of the macro. Typically `&body` parameters are used to hold a list of forms that make up the body of the macro.

Knowing this, the above macro definition can be condensed to:
```lisp
(defmacro do-primes ((var start end) &body body)
  `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
       ((> ,var ,end))
    ,@body))
```

In addition to being more concise, destructuring parameter lists also provide automatic error checking. With `DO-PRIMES` defined in this way Lisp will be able to detect a call whose first argument isn't a three-element list and will provide a meaningful error message. In development environments such as SLIME the environment will be able to communicate the syntax of the macro call.

[▲ Return to Sections](#sections)

## Generating the Expansion
A backquoted expression is similar to a quoted expression except that subexpressions can be "unquoted" by preceding them with a `,`. A subexpression (which must be a list) preceded by `,@` will be spliced into the enclosing list.

The backquote syntax is a particularly concise way of expressing code that generates lists: `` `(,a b)`` may be read as `(list a 'b)`. The language standard does not specify exactly what code the reader must produce as long as it generates the right list structure.

The following table shows examples of backquoted expressions, their equivalent list-building code, and the result of the backquoted expresion:

| Backquote Syntax         | Equivlent List-Building Code              | Result             |
| ------------------------ | ----------------------------------------- | ------------------ |
| `` `(a (+ 1 2) c)``      | `(list 'a '(+1 2) 'c)`                    | `(a (+ 1 2) c)`    |
| `` `(a ,(+ 1 2) c)``     | `(list 'a (+ 1 2) 'c)`                    | `(a 3 c)`          |
| `` `(a (list 1 2) c)``   | `(list 'a '(list 1 2) 'c)`                | `(a (list 1 2) c)` |
| `` `(a ,(list 1 2) c)``  | `(list 'a (list 1 2) 'c)`                 | `(a (1 2) c)`      |
| `` `(a ,@(list 1 2) c)`` | `(append (list 'a) (list 1 2) (list 'c))` | `(a 1 2 c)`        |

The backquote expression is a convenience. The previous definition of `DO-PRIMES` written using explicit list-building code would look like:
```lisp
(defmarco do-primes-a ((var start end) &body body)
  (append '(do)
          (list (list (list var
                            (list 'next-prime start)
                            (list 'next-prime (list '1+ var)))))
          (list (list (list '> var end)))
          body))
```

To verify if a macro definition works as intended there are 2 approaches:
1. Run the macro and if the resulting behavior is correct, it can be assumed the expression is correct:
```console
* (do-primes (p 0 19) (format t "~d " p))
2 3 5 7 11 13 17 19 
NIL
*
```
2. Check the macro directly by looking at the expansion of a particular call. The function `MACROEXPAND-1` takes any Lisp expression as an argument and returns the result of doing one level of macro expansion. Because `MACROEXPAND-1` is a function, to pass it a literal macro form, that form must be quoted:
```console
* (macroexpand-1 '(do-primes (p 0 19) (format t "~d " p)))
(DO ((P (NEXT-PRIME 0) (NEXT-PRIME (1+ P)))) ((> P 19)) (FORMAT T "~d " P))
T
*
```

[▲ Return to Sections](#sections)

## Plugging the Leaks
A _leaky abstraction_ is termed for an abstraction that leaks detaiks it is supposed to be abstracting away. Macros are a way of creating an abstraction and so should not leak.

The macro `DO-PRIMES` suffers from one of these leaks: it evaluates the `end` subform too many times:
```lisp
(defmacro do-primes ((var start end) &body body)
  `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
       ((> ,var ,end))
    ,@body))
```

If an expression, such as `(random 100)`, was passed as the `end` argument to `DO-PRIMES` the expression `(random 100)` would evaluate each time the runtime encounters the end test for the loop.  `(random 100)` will not be evaluated prior to being passed to `DO-PRIMES`.
```console
* (macroexpand-1 '(do-primes (p 0 (random 100)) (format t "~d " p)))
(DO ((P (NEXT-PRIME 0) (NEXT-PRIME (1+ P))))
    ((> P (RANDOM 100)))
  (FORMAT T "~d " P))
T
*
```

While the total number of iterations will still be random, it will be drawn from a much different distribution than the uniform distribution that `RANDOM` returns.

This is a leak because the caller of the macro needs to be aware that the `end` form is going to be evaluated more than once.

Prorammers calling `DO-PRIMES` would typically expect the forms passed to macros to be evaluated no more times than absolutely necessary. `DO-PRIMES` is modeled after the standard macros `DOTIMES` and `DOLIST`, neither of which causes any of the forms except those in the body to be evaluated more than once.

Following the Principle of Least Astonishment when implementing macros, the multiple evaluation should be fixed:
```lisp
(defmacro do-primes ((var start end) &body body)
  `(do ((ending-value ,end)
        (,var (next-prime ,start) (next-prime (1+ ,var))))
       ((> ,var ending-value))
      ,@body))
```

The above code evaluates the `end` form once to pass it to the `DO` loop's initialiation form. `DO-PRIMES` will no longer evaluate the `end` form on every iteration of the loop. However this introduces two more leaks.

The first leak this introduces is that beause the initialization forms for variables in a `DO` loop are evaluated in the order the variables are defined, when the macro expansion is evaluated, the expression passed as `end` will be evaluated before the expression passed as `start`, opposite the order they appear in the macro call.

To resolve this:
```lisp
(defmacro do-primes ((var start end) &body body)
  `(do ((,var (next-prime ,start) (next-prime (1+ ,var)))
        (ending-value ,end))
       ((> ,var ending-value))
      ,@body))
```

The above code reverses the order of the two variable definitions.

The final leak in this macro was created by using the variable name `ending-value`. The problem is that the name, which ought to be an internal detail of the macro implementation, can end up interacting with code passed to the macro, or in the context where the macro is called.

Because of this leak, the following macro call does not work:
```lisp
(do-primes (ending-value 0 10)
  (print ending-value))
```

`MACROEXPAND-1` reveals the issue:
```console
CL-USER> (macroexpand-1 (do-primes (ending-value 0 10) (print ending-value))) 
; in:
;      MACROEXPAND-1 (DO-PRIMES (ENDING-VALUE 0 10)
;                  (PRINT ENDING-VALUE))
;     (ENDING-VALUE 10)
; 
; caught ERROR:
;   The variable ENDING-VALUE occurs more than once in the LET.
; 
; compilation unit finished
;   caught 1 ERROR condition
Execution of a form compiled with errors.
```

The macro call would look like this expanded:
```lisp
(do ((ending-value (next-prime 0) (next-prime (1+ ending-value)))
     (ending-value 10))
    ((> ending-value ending-value))
  (print ending-value))
```

Some Lisps, like the console attempt at `MACROEXPAND-1` will reject this code because `ending-value` is used twice as a variable name in the same `DO` loop. If it is not rejected, the loop will run infinitely because `ending-value` will never be greater than itself.

Similarly this call to `DO-PRIMES` would also be problematic:
```lisp
(let ((ending-value 0))
  (do-primes (p 0 10)
    (incf ending-value p))
  ending-value)
```

This code will expand to:
```lisp
(let ((ending-value 0))
  (do ((p (next-prime 0) (next-prime (1+ p)))
       (ending-value 10))
      ((> p ending-value))
    (incf ending-value p))
  ending-value)
```

The generated code is perfectly legal but it will not behave as the programmer expected. In this expansion the binding of `ending-value` established by `LET` outside the loop is shadowed by the variable with the same name inside the `DO`. The form `(incf ending-value p)` increments the loop variable `ending-value` instead of the outer variable with the same name creating an infinite loop.

To patch this abstraction leak a symbol is needed, one that will never be used by the code calling the macro. The function `GENSYM` returns a unique symbol each time it's called. This symbol will never be read by the Lisp reader - it isn't interned in any package:
```lisp
(defmacro do-primes ((var start end) &body body)
  (let ((ending-value-name (gensym)))
    `(do ((,var (next-prime ,start) (next-prime (1+ ,var)))
          (,ending-value-name ,end))
         ((> ,var ,ending-value-name))
      ,@body)))
```

The code that calls `GENSYM` isn't part of the expansion - it runs as part of the macro expander and creates a new symbol each time the macro is expanded. With this definition the previous problematic forms expand as intended. The first form:
```lisp
(do-primes (ending-value 0 10)
  (print ending-value))
```

expands into:
```lisp
(do ((ending-value (next-prime 0) (next-prime (1+ ending-value)))
     (#:g2141 10))
    ((> ending-value #g2141))
  (print ending-value))
```

Now the variable used to hold the ending value is the gensymed symbol `#:g2141`.

The other previously problematic form:
```lisp
(let ((ending-value 0))
  (do-primes (p 0 10)
    (incf ending-value p))
  ending-value)
```

expands into:
```lisp
(let ((ending-value 0))
  (do ((p (next-prime 0) (next-prime (1+ p)))
       (#:g2140 10))
      ((> p #:g2140))
    (incf ending-value p))
  ending-value)
```

There is no leak because the `ending-value` variable bound by `LET` surrounding the `DO-PRIMES` loop is no longer shadowed by any variables introduced in the expanded code.

These general rules of thumb can help avoid writing macros with abstraction leaks:
* Unless there is a particular reason to do otherwise, include any subforms in the expansion in positions that will be evaluated in the same order as the subforms appear in the macro call.
* Unless there is a particular reason to do otherwise, make sure subforms are evaluated only once by creating a variable in the expansion to hold the value of evaluating the artgument form and then using that variable anywhere else the value is needed in the expansion.
* Use `GENSYM` at macro expansion time to create variable names used in the expansion.

[▲ Return to Sections](#sections)

## Macro-Writing Macros
Some patterns come up again and again in writing macros that can benefit from being abstracted away. One such pattern is a macro expansion that begins with a `LET` that introduces variables holding gensymed sumbols to be used in the expansion.

A macro-writing macro is a macro that generates code that in turn generates code. While complex macro-writing-macros can get confusing, this `WITH-GENSYMS` is pretty straightforward. The goal is to be able to write the `DO-PRIMES` macro definition simpler:
```lisp
(defmacro do-primes ((var start end) &body body)
  (with-gensyms (ending-value-name)
    `(do ((,var (next-prime ,start) (next-prime (1+ ,var)))
          (,ending-value-name ,end))
         ((> ,var ,ending-value-name))
       ,@body)))
```

In order to define `WITH-GENSYMS` so that the above macro expands to the same resulting code as before, the `WITH-GENSYMS` macro must expand into a `LET` that binds each named variable (in this case `ending-value-name`) to a gensymed symbol:
```lisp
(defmacro with-gensyms ((&rest names) &body body)
  `(let ,(loop for n in names collect `(,n (gensym)))
    ,@body))
```

The comma in the above definition is used to interpolate the value of the `LOOP` expression. The loop generates a list of binding forms where each binding form consists of a list containing one of the names given to `WITH-GENSYMS` and the literal code `(gensym)`. To test the code the `LOOP` expression would generate:
```console
CL-USER> (loop for n in '(a b c) collect `(,n (gensym))) 
((A (GENSYM)) (B (GENSYM)) (C (GENSYM)))
CL-USER> 
```

After the list of binding forms, the body argument to `WITH-GENSYMS` is spliced in as the body of the `LET` form.

Expanding the form of the new definition of `DO-PRIMES` results in something like:
```lisp
(let ((ending-value-name (gensym)))
  `(do ((,var (next-prime ,start) (next-prime (1+ ,var)))
        (,ending-value-name ,end))
       ((> ,var ,ending-value-name))
      ,@body))
```

When the `DEFMACRO` of `DO-PRIMES` is expanded, the `WITH-GENSYMS` form is expanded into the code and compiled. The compiled version of `DO-PRIMES` is the same as if the outer `LET` form had been written by hand. When a function that uses `DO-PRIMES` is compiled, the code _generated_ by `WITH-GENSYMS` runs generated the `DO-PRIMES` expansion. The `WITH-GENSYMS` macro itself isn't needed to compile a `DO-PRIMES` form since it has already been expanded, back when `DO-PRIMES` itself was compiled.

### ONCE-ONLY
Another classic macro-writing macro is `ONCE-ONLY`, which is used to generate code that evaluate certain macro arguments only once and in a particular order. Using `ONCE-ONLY` the definition for `DO-PRIMES` could be written almost as simply as the original leaky version:
```lisp
(defmacro do-primes ((var start end) &body body)
  (once-only (start end)
    `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
         ((> ,var ,end))
        ,@body)))
```

The implementation of `ONCE-ONLY` relies on multiple levels of backquoting and unquoting:
```lisp
(defmacro once-only ((&rest names) &body body)
  (let ((gensyms (loop for n in names collect (gensym))))
    `(let (,@(loop for g in gensyms collect `(,g (gensym))))
      `(let (,,@(loop for g in gensyms for n in names collect ``(,,g ,,n)))
        ,(let (,@(loop for n in names for g in gensyms collect `(,n ,g)))
          ,@body)))))
```

[▲ Return to Sections](#sections)

| [Previous: Macros: Standard Control Structures](../07/README.md) | [Table of Contents](../README.md#notes) | Next |
