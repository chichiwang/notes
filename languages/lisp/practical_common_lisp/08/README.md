# Macros: Custom Defined
[Chapter Link](http://www.gigamonkeys.com/book/macros-defining-your-own.html)

Perhaps the biggest barrier to proper understanding of macros is that they are so well integrated into the language. The key to understanding macros is to clearly understand the distinction between the code that generates code (macros) and the code that eventually makes up the program (everything else).

## Sections
* [Macro Expansion vs. Runtime](#macro-expanson-vs-runtime)
* [DEFMACRO](#defmacro)
* [A Sample Macro: do-primes](#a-sample-macro-do-primes)

[◂ Return to Table of Contents](../README.md)

## Macro Expansion vs. Runtime
A macro definition is a program that will be used by the compiler to generate the code that will then be compiled. Only after all macros have been fully expanded and the resulting code compiled can a program run. _Macro expansion time_ is the step where macros are executed. This is distinct from _runtime_ when regular code, including the code generated by macros, run.

Code running at macro expansion time runs in a very different environment than code running at runtime. At macro expansion time there is no way to access the data that will exist at runtime: code running at macro expansion time can deal only with the data that's inherent in the source code.

Take the example of the following code:
```lisp
(defun foo (x)
  (when (> x 10) (print 'big)))
```

`WHEN` is a macro. At macro expansion time there is no call to `FOO` and therefore there is no value associated with `x`. The values the compiler passes to `WHEN` are the Lisp lists representing the source code: `(> x 10)` and `(print 'big)`. Supposing that `WHEN` is defined the following way:
```lisp
(defmacro when (condition &rest body)
  `(if ,condition (progn ,@body)))
```

When the code in `FOO` is compiled, the `WHEN` macro will be run with those two forms as arguments. The parameter `condition` will be bound to the form `(> x 10)`, and the form `(print 'big)` will be collected into a list that will become the value of the `&rest body` parameter. The backquote expression will generate this code:
```lisp
(if (> x 10) (progn (print 'big)))
```

When Lisp is interpreted, rather than compiked, this distinction between macro expansion time and runtime is less clear because they are temporally intertwined. The language doesn't specify exactly how an interpreter must handle macros. Regardless, macros are always passed the unevaluated Lisp objects representing the subforms of the macro form. The job of the macro is to produce code that will do something rather than to do anything directly.

[▲ Return to Sections](#sections)

## DEFMACRO
`DEFMACRO` stands for _DEFine MACRO_ and is used to define a macro. The basica skeleton of `DEFMACRO` is:
```lisp
(defmacro name (parameter*)
  "Optional documentation string."
  body-form*)
```

Macros can use the full power of Lisp to generate their expansion. The job of a macro is to translate a macro form (a lisp form whose first element is the name of the macro) into code that does a particular thing. The first step of writing a macro is to write at least one example of a call to the macro and the code into which that code should expand. The second step is to write the actual macro code.

Simple macros will consist of a backquoted template with macro parameters plugged into the right places. Complex macros will be significant programs in their own right, complete with helper functions and data structures.

After writing the macro, it needs to be hardened against leaking details of its implementation. Leaky macro abstractions can potentially interact with code in the calling environment in undesirable ways.

To sum up creating a macro:
1. Write a sample call to the macro and the code it should expand into.
2. Write code that generates the handwritten expansion fronm the arguments in the sample call.
3. Ensure the macro abstraction does not leak.

[▲ Return to Sections](#sections)

## A Sample Macro: do-primes
We will create a sample macro `DO-PRIMES` that provides a looping construct similar to `DOTIMES` and `DOLIST` except that instead of iterating over integers or elements of a list, it iterates over successive prime numbers.

First we define utility functions:
```lisp
(defun primep (number)
  (when (> number 1)
    (loop for fac from 2 to (isqrt number) never (zerop (mod number fac)))))

(defun next-prime (number)
  (loop for n from number when (primep n) return n))
```

`PRIMEP` tests whether a given number is prime. `NEXT-PRIME` returns the next prime number greater than or equal to its argument.

Following the steps from the [previous section](#defmacro), first we need one example call to the macro:
```lisp
(do-primes (p 0 19)
  (format t "~d" p))
```

The above code intends to express a loop that executes the body once each for each prime number greater or equal to `0` and less than or equal to `19`. The variable `p` will be assigned to that number on every iteration of the `DO-PRIMES` loop.

The above code could expand to:
```lisp
(do ((p (next-prime 0) (next-prime (+1 p))))
    ((> p 19))
  (format t "~d" p))
```

[▲ Return to Sections](#sections)

| [Previous: Macros: Standard Control Structures](../07/README.md) | [Table of Contents](../README.md#notes) | Next |
