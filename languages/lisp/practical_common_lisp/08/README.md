# Macros: Custom Defined
[Chapter Link](http://www.gigamonkeys.com/book/macros-defining-your-own.html)

Perhaps the biggest barrier to proper understanding of macros is that they are so well integrated into the language. The key to understanding macros is to clearly understand the distinction between the code that generates code (macros) and the code that eventually makes up the program (everything else).

## Sections
* [Macro Expansion vs. Runtime](#macro-expanson-vs-runtime)
* [DEFMACRO](#defmacro)
* [A Sample Macro: do-primes](#a-sample-macro-do-primes)
* [Macro Parameters](#macro-parameters)
* [Generating the Expansion](#generating-the-expansion)

[◂ Return to Table of Contents](../README.md)

## Macro Expansion vs. Runtime
A macro definition is a program that will be used by the compiler to generate the code that will then be compiled. Only after all macros have been fully expanded and the resulting code compiled can a program run. _Macro expansion time_ is the step where macros are executed. This is distinct from _runtime_ when regular code, including the code generated by macros, run.

Code running at macro expansion time runs in a very different environment than code running at runtime. At macro expansion time there is no way to access the data that will exist at runtime: code running at macro expansion time can deal only with the data that's inherent in the source code.

Take the example of the following code:
```lisp
(defun foo (x)
  (when (> x 10) (print 'big)))
```

`WHEN` is a macro. At macro expansion time there is no call to `FOO` and therefore there is no value associated with `x`. The values the compiler passes to `WHEN` are the Lisp lists representing the source code: `(> x 10)` and `(print 'big)`. Supposing that `WHEN` is defined the following way:
```lisp
(defmacro when (condition &rest body)
  `(if ,condition (progn ,@body)))
```

When the code in `FOO` is compiled, the `WHEN` macro will be run with those two forms as arguments. The parameter `condition` will be bound to the form `(> x 10)`, and the form `(print 'big)` will be collected into a list that will become the value of the `&rest body` parameter. The backquote expression will generate this code:
```lisp
(if (> x 10) (progn (print 'big)))
```

When Lisp is interpreted, rather than compiked, this distinction between macro expansion time and runtime is less clear because they are temporally intertwined. The language doesn't specify exactly how an interpreter must handle macros. Regardless, macros are always passed the unevaluated Lisp objects representing the subforms of the macro form. The job of the macro is to produce code that will do something rather than to do anything directly.

[▲ Return to Sections](#sections)

## DEFMACRO
`DEFMACRO` stands for _DEFine MACRO_ and is used to define a macro. The basica skeleton of `DEFMACRO` is:
```lisp
(defmacro name (parameter*)
  "Optional documentation string."
  body-form*)
```

Macros can use the full power of Lisp to generate their expansion. The job of a macro is to translate a macro form (a lisp form whose first element is the name of the macro) into code that does a particular thing. The first step of writing a macro is to write at least one example of a call to the macro and the code into which that code should expand. The second step is to write the actual macro code.

Simple macros will consist of a backquoted template with macro parameters plugged into the right places. Complex macros will be significant programs in their own right, complete with helper functions and data structures.

After writing the macro, it needs to be hardened against leaking details of its implementation. Leaky macro abstractions can potentially interact with code in the calling environment in undesirable ways.

To sum up creating a macro:
1. Write a sample call to the macro and the code it should expand into.
2. Write code that generates the handwritten expansion fronm the arguments in the sample call.
3. Ensure the macro abstraction does not leak.

[▲ Return to Sections](#sections)

## A Sample Macro: do-primes
We will create a sample macro `DO-PRIMES` that provides a looping construct similar to `DOTIMES` and `DOLIST` except that instead of iterating over integers or elements of a list, it iterates over successive prime numbers.

First we define utility functions:
```lisp
(defun primep (number)
  (when (> number 1)
    (loop for fac from 2 to (isqrt number) never (zerop (mod number fac)))))

(defun next-prime (number)
  (loop for n from number when (primep n) return n))
```

`PRIMEP` tests whether a given number is prime. `NEXT-PRIME` returns the next prime number greater than or equal to its argument.

Following the steps from the [previous section](#defmacro), first we need one example call to the macro:
```lisp
(do-primes (p 0 19)
  (format t "~d" p))
```

The above code intends to express a loop that executes the body once each for each prime number greater or equal to `0` and less than or equal to `19`. The variable `p` will be assigned to that number on every iteration of the `DO-PRIMES` loop.

The above code could expand to:
```lisp
(do ((p (next-prime 0) (next-prime (+1 p))))
    ((> p 19))
  (format t "~d" p))
```

[▲ Return to Sections](#sections)

## Macro Parameters
The first step in any macro is to extract the parts of the lisp argument objects that are needed to compute the expansion. For macros that simply interpolate their arguments directly into a template this step is trivial - defining the right parameters to hold the different arguments will suffice.

This is a bit more complex for a macro like `DO-PRIMES`. The first argument to the `DO-PRIMES` call is a list containing the name of the loop variable `p`, the lower bound `0`, and the upper bound `19`. This list as a whole does not appear in the expansion, these three arguments are split up in different locations.

`DO-PRIMES` can be defined with two parameters: one to hold the list and a `&rest` parameter to hold the body forms. The list will need to be taken apart:
```lisp
(defmacro do-primes (var-and-range &rest body)
  (let ((var (first var-and-range))
        (start (second var-and-range))
        (end (third var-and-range)))
    `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
         ((> ,var ,end))
      ,@body)))
```

In the above definition the variables `var`, `start`, and `end` each hold a value extracted from `var-and-range`. These variables are then interpolated into the backquote expression that generates `DO-PRIME`'s expansion.

`var-and-range` does not need to be extracted explicitly in this way, however, because macro parameter lists are what are called _destructuring_ parameter lists. Destructuring involves taking apart a structure (in this case the list structure of the forms passed to a macro).

Within a destructuring parameter list a parameter name can be replaced with a nested parameter list. For example, `var-and-range` in the above definition can be replaced with a list `(var start end)` and the three elements in the list will automatically be destructured into those three parameters.

Another special feature of macro parameter lists is that `&body` can be used as a synonym for `&rest`. Semantically `&body` and `&rest` are equivalent, but many development environments will use the presence of a `&body` parameter to modify how they indent uses of the macro. Typically `&body` parameters are used to hold a list of forms that make up the body of the macro.

Knowing this, the above macro definition can be condensed to:
```lisp
(defmacro do-primes ((var start end) &body body)
  `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
       ((> ,var ,end))
    ,@body))
```

In addition to being more concise, destructuring parameter lists also provide automatic error checking. With `DO-PRIMES` defined in this way Lisp will be able to detect a call whose first argument isn't a three-element list and will provide a meaningful error message. In development environments such as SLIME the environment will be able to communicate the syntax of the macro call.

[▲ Return to Sections](#sections)

## Generating the Expansion
A backquoted expression is similar to a quoted expression except that subexpressions can be "unquoted" by preceding them with a `,`. A subexpression (which must be a list) preceded by `,@` will be spliced into the enclosing list.

The backquote syntax is a particularly concise way of expressing code that generates lists: `` `(,a b)`` may be read as `(list a 'b)`. The language standard does not specify exactly what code the reader must produce as long as it generates the right list structure.

The following table shows examples of backquoted expressions, their equivalent list-building code, and the result of the backquoted expresion:

| Backquote Syntax         | Equivlent List-Building Code              | Result             |
| ------------------------ | ----------------------------------------- | ------------------ |
| `` `(a (+ 1 2) c)``      | `(list 'a '(+1 2) 'c)`                    | `(a (+ 1 2) c)`    |
| `` `(a ,(+ 1 2) c)``     | `(list 'a (+ 1 2) 'c)`                    | `(a 3 c)`          |
| `` `(a (list 1 2) c)``   | `(list 'a '(list 1 2) 'c)`                | `(a (list 1 2) c)` |
| `` `(a ,(list 1 2) c)``  | `(list 'a (list 1 2) 'c)`                 | `(a (1 2) c)`      |
| `` `(a ,@(list 1 2) c)`` | `(append (list 'a) (list 1 2) (list 'c))` | `(a 1 2 c)`        |

The backquote expression is a convenience. The previous definition of `DO-PRIMES` written using explicit list-building code would look like:
```lisp
(defmarco do-primes-a ((var start end) &body body)
  (append '(do)
          (list (list (list var
                            (list 'next-prime start)
                            (list 'next-prime (list '1+ var)))))
          (list (list (list '> var end)))
          body))
```

To verify if a macro definition works as intended there are 2 approaches:
1. Run the macro and if the resulting behavior is correct, it can be assumed the expression is correct:
```console
* (do-primes (p 0 19) (format t "~d " p))
2 3 5 7 11 13 17 19 
NIL
*
```
2. Check the macro directly by looking at the expansion of a particular call. The function `MACROEXPAND-1` takes any Lisp expression as an argument and returns the result of doing one level of macro expansion. Because `MACROEXPAND-1` is a function, to pass it a literal macro form, that form must be quoted:
```console
* (macroexpand-1 '(do-primes (p 0 19) (format t "~d " p)))
(DO ((P (NEXT-PRIME 0) (NEXT-PRIME (1+ P)))) ((> P 19)) (FORMAT T "~d " P))
T
*
```

[▲ Return to Sections](#sections)

| [Previous: Macros: Standard Control Structures](../07/README.md) | [Table of Contents](../README.md#notes) | Next |
