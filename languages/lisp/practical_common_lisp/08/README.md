# Macros: Custom Defined
[Chapter Link](http://www.gigamonkeys.com/book/macros-defining-your-own.html)

Perhaps the biggest barrier to proper understanding of macros is that they are so well integrated into the language. The key to understanding macros is to clearly understand the distinction between the code that generates code (macros) and the code that eventually makes up the program (everything else).

## Sections
* [Macro Expansion vs. Runtime](#macro-expanson-vs-runtime)

[◂ Return to Table of Contents](../README.md)

## Macro Expansion vs. Runtime
A macro definition is a program that will be used by the compiler to generate the code that will then be compiled. Only after all macros have been fully expanded and the resulting code compiled can a program run. _Macro expansion time_ is the step where macros are executed. This is distinct from _runtime_ when regular code, including the code generated by macros, run.

Code running at macro expansion time runs in a very different environment than code running at runtime. At macro expansion time there is no way to access the data that will exist at runtime: code running at macro expansion time can deal only with the data that's inherent in the source code.

Take the example of the following code:
```lisp
(defun foo (x)
  (when (> x 10) (print 'big)))
```

`WHEN` is a macro. At macro expansion time there is no call to `FOO` and therefore there is no value associated with `x`. The values the compiler passes to `WHEN` are the Lisp lists representing the source code: `(> x 10)` and `(print 'big)`. Supposing that `WHEN` is defined the following way:
```lisp
(defmacro when (condition &rest body)
  `(if ,condition (progn ,@body)))
```

When the code in `FOO` is compiled, the `WHEN` macro will be run with those two forms as arguments. The parameter `condition` will be bound to the form `(> x 10)`, and the form `(print 'big)` will be collected into a list that will become the value of the `&rest body` parameter. The backquote expression will generate this code:
```lisp
(if (> x 10) (progn (print 'big)))
```

When Lisp is interpreted, rather than compiked, this distinction between macro expansion time and runtime is less clear because they are temporally intertwined. The language doesn't specify exactly how an interpreter must handle macros. Regardless, macros are always passed the unevaluated Lisp objects representing the subforms of the macro form. The job of the macro is to produce code that will do something rather than to do anything directly.

[▲ Return to Sections](#sections)

| [Previous: Macros: Standard Control Structures](../07/README.md) | [Table of Contents](../README.md#notes) | Next |
